"use client";

import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState
} from "react";
import { useTheme } from "./ThemeProvider";

const VideoPanelContext = createContext(null);

const SESSION_TIMERS_ENDPOINT = "/api/session-timers";
const SESSION_TIMERS_STORAGE_KEY = "kalon_session_timers";
const PERSIST_THROTTLE_MS = 10000;

const DEFAULT_SESSION_DATA = {
  lastSession: {
    start: null,
    elapsed: 0,
    status: "idle"
  },
  history: []
};

const formatDate = (date) => {
  if (!(date instanceof Date) || Number.isNaN(date.valueOf())) {
    return new Date().toISOString().split("T")[0];
  }
  return date.toISOString().split("T")[0];
};

export const VideoPanelProvider = ({
  children,
  isProfessional = true,
  onSessionEnd,
  sessionDuration = 60,
  elapsedTime: initialElapsedTime = 0,
  warningThreshold = 5
}) => {
  const { getThemeColors } = useTheme();
  const themeColors = getThemeColors();

  // ============================================================
  // ðŸ§± CENTRALIZED STATE MANAGEMENT
  // ============================================================
  const [session, setSession] = useState({
    status: "idle",
    duration: sessionDuration,
    history: [],
    startedAt: null
  });

  const [media, setMedia] = useState({
    isVideoEnabled: false,
    isAudioEnabled: false,
    isPreviewOn: false,
    hasStream: false,
    isScreenSharing: false
  });

  const [connection, setConnection] = useState({
    isConnected: false,
    isPreConnected: false,
    lowPowerMode: false
  });

  // UI State
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [showTimeWarning, setShowTimeWarning] = useState(false);
  const [showScreenSharePanel, setShowScreenSharePanel] = useState(false);
  const [useWhereby, setUseWhereby] = useState(false);
  const [isHighMeshEnabled, setIsHighMeshEnabled] = useState(false);
  const [recordingState, setRecordingState] = useState({ active: false, notifyClient: false });
  const [consultationId, setConsultationId] = useState(null);
  const [permissionError, setPermissionError] = useState(null);

  // Refs for async safety
  const localVideoRef = useRef(null);
  const remoteVideoRef = useRef(null);
  const screenShareRef = useRef(null);
  const streamRef = useRef(null);
  const sessionTimerRef = useRef(null);
  const persistQueueRef = useRef(null);
  const lastPersistTimeRef = useRef(0);
  const persistenceModeRef = useRef("api");
  const sessionRef = useRef(session);
  const elapsedTimeStateRef = useRef(initialElapsedTime);

  // ============================================================
  // â± SESSION STATE (declared early for use in persist)
  // ============================================================
  const [elapsedTimeState, setElapsedTime] = useState(initialElapsedTime);

  // Update refs when state changes
  useEffect(() => {
    sessionRef.current = session;
  }, [session]);

  useEffect(() => {
    elapsedTimeStateRef.current = elapsedTimeState;
  }, [elapsedTimeState]);

  // Sync session duration from props
  useEffect(() => {
    setSession(prev => {
      if (prev.duration === sessionDuration) return prev;
      return { ...prev, duration: sessionDuration };
    });
  }, [sessionDuration]);

  // ============================================================
  // ðŸ’¾ UNIFIED PERSISTENCE
  // ============================================================
  const persist = useCallback(async (force = false) => {
    const now = Date.now();

    if (!force && now - lastPersistTimeRef.current < PERSIST_THROTTLE_MS) {
      if (persistQueueRef.current) clearTimeout(persistQueueRef.current);
      const delay = PERSIST_THROTTLE_MS - (now - lastPersistTimeRef.current);
      persistQueueRef.current = setTimeout(() => persist(true), delay);
      return;
    }

    lastPersistTimeRef.current = now;
    if (persistQueueRef.current) {
      clearTimeout(persistQueueRef.current);
      persistQueueRef.current = null;
    }

    const currentSession = sessionRef.current;
    const currentElapsedTime = elapsedTimeStateRef.current;

    const data = {
      lastSession: {
        start: currentSession.startedAt,
        elapsed: currentSession.status === "idle" ? 0 : currentElapsedTime,
        status: currentSession.status
      },
      history: currentSession.history
    };

    if (persistenceModeRef.current !== "localStorage") {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 2000);

        const response = await fetch(SESSION_TIMERS_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(data),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (response.ok) return;
        throw new Error("API save failed");
      } catch (error) {
        if (error.name !== 'AbortError') {
          persistenceModeRef.current = "localStorage";
        }
      }
    }

    try {
      localStorage.setItem(SESSION_TIMERS_STORAGE_KEY, JSON.stringify(data));
    } catch {
      // Ignore storage errors
    }
  }, []);

  // ============================================================
  // ðŸ§² MEDIA MANAGER
  // ============================================================
  const mediaManager = useRef({
    // âœ… RESTORED: Standard getUserMedia logic with PHYSICAL CAMERA SELECTION
    async startStream() {
      console.log("ðŸŽ¬ mediaManager.startStream: Iniciando Preview Local");

      if (streamRef.current) {
        return streamRef.current;
      }

      try {
        // ðŸŽ¯ ENUMERATE DEVICES TO FIND PHYSICAL CAMERA
        console.log("ðŸ“¡ Enumerando dispositivos...");
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(d => d.kind === 'videoinput');

        console.log(`ðŸ“¹ Encontradas ${videoDevices.length} cÃ¢mera(s):`);
        videoDevices.forEach(d => console.log(`   - ${d.label}`));

        // Procurar pela C920 fÃ­sica (nÃ£o virtual)
        const physicalCamera = videoDevices.find(d =>
          d.label.includes('C920') && !d.label.includes('Logi Capture')
        );

        const constraints = {
          video: physicalCamera
            ? { deviceId: { exact: physicalCamera.deviceId }, width: { ideal: 1280 }, height: { ideal: 720 } }
            : { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: "user" },
          audio: true
        };

        if (physicalCamera) {
          console.log(`âœ… Usando cÃ¢mera fÃ­sica: ${physicalCamera.label}`);
        } else {
          console.log("âš ï¸ C920 nÃ£o encontrada, usando cÃ¢mera padrÃ£o");
        }

        console.log("ðŸ“¡ Chamando navigator.mediaDevices.getUserMedia...");
        const stream = await navigator.mediaDevices.getUserMedia(constraints);

        streamRef.current = stream;

        // Garantir que os tracks comecem habilitados
        stream.getTracks().forEach(t => t.enabled = true);

        return stream;
      } catch (error) {
        console.error("âŒ Erro no getUserMedia:", error);
        setPermissionError(error.message || "Erro de permissÃ£o da cÃ¢mera");
        return null;
      }
    },

    stopStream() {
      if (streamRef.current) {
        streamRef.current.getTracks().forEach((track) => track.stop());
        streamRef.current = null;
      }
      setMedia((prev) => ({ ...prev, hasStream: false, isPreviewOn: false, isVideoEnabled: false, isAudioEnabled: false }));
      setConnection((prev) => ({ ...prev, isConnected: false }));
      if (localVideoRef.current) {
        localVideoRef.current.srcObject = null;
      }
    },

    async setVideoTrackEnabled(enabled) {
      const stream = await this.getStream();
      if (!stream) return;

      const videoTrack = stream.getVideoTracks()[0];
      if (videoTrack) {
        videoTrack.enabled = enabled;
      }
    },

    async enableVideo(enabled) {
      console.log(`ðŸŽ¥ mediaManager.enableVideo(${enabled}) called`);
      try {
        await this.setVideoTrackEnabled(enabled);
      } catch (e) {
        console.warn("âš ï¸ setVideoTrackEnabled failed, but forcing state update:", e);
      }
      setMedia((prev) => {
        console.log(`âœ… Updating isVideoEnabled to ${enabled}`);
        return { ...prev, isVideoEnabled: enabled };
      });
    },

    async enableAudio(enabled) {
      const stream = await this.getStream();
      if (!stream) return;

      const audioTrack = stream.getAudioTracks()[0];
      if (audioTrack) {
        audioTrack.enabled = enabled;
        setMedia((prev) => ({ ...prev, isAudioEnabled: enabled }));
      }
    },

    async getStream() {
      if (streamRef.current) return streamRef.current;
      return await this.startStream();
    }
  }).current;

  // ============================================================
  // ðŸ“¸ VIDEO PREVIEW MANAGER
  // ============================================================
  const videoPreview = useRef({
    update(stream) {
      if (localVideoRef.current && stream) {
        localVideoRef.current.srcObject = stream;
      }
    },

    show() {
      console.log("ðŸ“¸ videoPreview.show() chamado");
      if (streamRef.current && localVideoRef.current) {
        localVideoRef.current.srcObject = streamRef.current;
        console.log("âœ… srcObject configurado com sucesso");
      } else {
        console.error("âŒ NÃ£o foi possÃ­vel configurar srcObject");
      }
    },

    hide() {
      if (localVideoRef.current) {
        localVideoRef.current.srcObject = null;
      }
      setMedia((prev) => ({ ...prev, isPreviewOn: false }));
    }
  }).current;

  // ============================================================
  // â± SESSION MACHINE
  // ============================================================
  const sessionMachineStart = useCallback(() => {
    const startIso = new Date().toISOString();

    setSession((prev) => ({
      status: "active",
      duration: sessionDuration,
      history: prev.history,
      startedAt: startIso
    }));

    setElapsedTime(0);

    if (sessionTimerRef.current) clearInterval(sessionTimerRef.current);
    sessionTimerRef.current = setInterval(() => {
      setElapsedTime((prev) => prev + 1);
    }, 1000);

    persist(true);
  }, [sessionDuration, persist]);

  const sessionMachinePause = useCallback(() => {
    setSession((prev) => {
      if (prev.status !== "active") return prev;
      return { ...prev, status: "paused" };
    });

    if (sessionTimerRef.current) {
      clearInterval(sessionTimerRef.current);
      sessionTimerRef.current = null;
    }

    persist(true);
  }, [persist]);

  const sessionMachineResume = useCallback(() => {
    setSession((prev) => {
      if (prev.status !== "paused") return prev;
      return { ...prev, status: "active" };
    });

    if (sessionTimerRef.current) clearInterval(sessionTimerRef.current);
    sessionTimerRef.current = setInterval(() => {
      setElapsedTime((prev) => prev + 1);
    }, 1000);

    persist(true);
  }, [persist]);

  const sessionMachineReset = useCallback(() => {
    setSession((prev) => {
      const duration = elapsedTimeState;
      const sessionStart = prev.startedAt ? new Date(prev.startedAt) : new Date();
      const historyEntry = duration > 0 ? {
        date: formatDate(sessionStart),
        duration
      } : null;

      return {
        status: "idle",
        duration: sessionDuration,
        history: historyEntry ? [historyEntry, ...prev.history] : prev.history,
        startedAt: null
      };
    });

    setElapsedTime(0);

    if (sessionTimerRef.current) {
      clearInterval(sessionTimerRef.current);
      sessionTimerRef.current = null;
    }

    persist(true);
  }, [elapsedTimeState, sessionDuration, persist]);

  const sessionMachineEnd = useCallback(() => {
    const duration = elapsedTimeState;
    sessionMachineReset();
    if (onSessionEnd) {
      onSessionEnd({ duration, wasRecorded: false });
    }
  }, [elapsedTimeState, sessionMachineReset, onSessionEnd]);

  const sessionMachine = useMemo(() => ({
    start: sessionMachineStart,
    pause: sessionMachinePause,
    resume: sessionMachineResume,
    reset: sessionMachineReset,
    end: sessionMachineEnd
  }), [sessionMachineStart, sessionMachinePause, sessionMachineResume, sessionMachineReset, sessionMachineEnd]);

  // ============================================================
  // ðŸ”— CONNECTION LOGIC
  // ============================================================
  useEffect(() => {
    const stored = localStorage.getItem("kalonLowPowerMode");
    const enabled = stored ? JSON.parse(stored) : false;
    setConnection((prev) => ({ ...prev, lowPowerMode: enabled }));

    const handleChange = (event) => {
      const value = Boolean(event.detail?.enabled);
      setConnection((prev) => ({ ...prev, lowPowerMode: value }));
      window.dispatchEvent(
        new CustomEvent("kalon:media-control", {
          detail: { action: value ? "pause-waiting-music" : "resume-waiting-music" }
        })
      );
    };

    window.addEventListener("lowPowerModeChanged", handleChange);
    return () => window.removeEventListener("lowPowerModeChanged", handleChange);
  }, []);

  useEffect(() => {
    const handleVisibility = () => {
      if (!connection.lowPowerMode) return;
      window.dispatchEvent(
        new CustomEvent("kalon:media-control", {
          detail: { action: document.visibilityState === "hidden" ? "pause-waiting-music" : "resume-waiting-music" }
        })
      );
    };

    document.addEventListener("visibilitychange", handleVisibility);
    return () => document.removeEventListener("visibilitychange", handleVisibility);
  }, [connection.lowPowerMode]);

  useEffect(() => {
    if (session.status !== "active") {
      setShowTimeWarning(false);
      return;
    }

    const remainingSeconds = sessionDuration * 60 - elapsedTimeState;
    setShowTimeWarning(remainingSeconds <= warningThreshold * 60);
  }, [elapsedTimeState, sessionDuration, session.status, warningThreshold]);

  // ============================================================
  // ðŸ’¾ LOAD SESSION DATA
  // ============================================================
  useEffect(() => {
    if (typeof window === "undefined") return;

    let cancelled = false;

    const mergeSessionData = (data) => ({
      lastSession: {
        ...DEFAULT_SESSION_DATA.lastSession,
        ...(data?.lastSession || {})
      },
      history: Array.isArray(data?.history) ? data.history : []
    });

    const loadSessionData = async () => {
      let loaded = DEFAULT_SESSION_DATA;

      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 2000);

        const response = await fetch(SESSION_TIMERS_ENDPOINT, {
          signal: controller.signal
        });
        clearTimeout(timeoutId);

        if (response.ok) {
          const payload = await response.json();
          loaded = mergeSessionData(payload);
          persistenceModeRef.current = "api";
        } else {
          throw new Error("Failed request");
        }
      } catch (error) {
        if (error.name !== 'AbortError') {
          try {
            const raw = localStorage.getItem(SESSION_TIMERS_STORAGE_KEY);
            if (raw) {
              loaded = mergeSessionData(JSON.parse(raw));
            }
          } catch {
            // Ignore parse errors
          }
        }
        persistenceModeRef.current = "localStorage";
      }

      if (cancelled) return;

      const { lastSession } = loaded;
      setSession({
        status: lastSession.status || "idle",
        duration: sessionDuration,
        history: loaded.history,
        startedAt: lastSession.start
      });

      if (lastSession.elapsed > 0) {
        setElapsedTime(lastSession.elapsed);
      }

      const sessionStartTime = lastSession.start ? new Date(lastSession.start).getTime() : 0;
      const now = Date.now();
      const hoursSinceStart = (now - sessionStartTime) / (1000 * 60 * 60);
      const isRecentSession = hoursSinceStart < 24;

      if (lastSession.status === "active" && isRecentSession && lastSession.elapsed > 0) {
        setTimeout(() => {
          if (cancelled || typeof window === "undefined") return;
          const resume = window.confirm(
            "HÃ¡ uma sessÃ£o em andamento. Deseja retomar o contador anterior ou iniciar do zero?"
          );
          if (resume) {
            setElapsedTime(lastSession.elapsed || 0);
            setSession((prev) => ({ ...prev, status: "active", startedAt: lastSession.start }));
            if (sessionTimerRef.current) clearInterval(sessionTimerRef.current);
            sessionTimerRef.current = setInterval(() => {
              setElapsedTime((prev) => prev + 1);
            }, 1000);
          } else {
            setSession((prev) => ({
              ...prev,
              status: "idle",
              startedAt: null
            }));
            setElapsedTime(0);
            persist(true);
          }
        }, 500);
      } else {
        setSession((prev) => ({
          ...prev,
          status: "idle",
          startedAt: null
        }));
        setElapsedTime(0);
      }
    };

    loadSessionData();

    return () => {
      cancelled = true;
      if (persistQueueRef.current) {
        clearTimeout(persistQueueRef.current);
        persistQueueRef.current = null;
      }
    };
  }, [sessionDuration]);

  // ============================================================
  // ðŸ§¹ CLEANUP ON UNMOUNT
  // ============================================================
  useEffect(() => {
    return () => {
      // âœ… NÃƒO parar tracks automaticamente - apenas limpar timers
      // A cÃ¢mera sÃ³ deve ser parada por aÃ§Ã£o explÃ­cita do usuÃ¡rio
      if (sessionTimerRef.current) {
        clearInterval(sessionTimerRef.current);
      }
      if (persistQueueRef.current) {
        clearTimeout(persistQueueRef.current);
      }
      persist(true);
    };
  }, []);

  // ============================================================
  // ðŸŽ› PUBLIC API FUNCTIONS
  // ============================================================
  const toggleAudio = useCallback(async () => {
    const nextState = !media.isAudioEnabled;
    await mediaManager.enableAudio(nextState);
  }, [media.isAudioEnabled, mediaManager]);

  const toggleCameraPreview = useCallback(async () => {
    console.log("ðŸŽ¥ toggleCameraPreview: INÃCIO", { isPreviewOn: media.isPreviewOn });

    if (media.isPreviewOn) {
      console.log("ðŸ”´ Desligando cÃ¢mera...");
      mediaManager.stopStream();
      videoPreview.hide();
      setMedia((prev) => ({ ...prev, isPreviewOn: false }));
      console.log("âœ… CÃ¢mera desligada");
    } else {
      console.log("ðŸŸ¢ Ligando cÃ¢mera...");
      try {
        console.log("ðŸ“¡ Solicitando stream...");
        const stream = await mediaManager.startStream();
        console.log("ðŸ“¡ Stream recebido:", stream);

        if (stream) {
          console.log("âœ… Stream OK, habilitando track...");
          await mediaManager.setVideoTrackEnabled(true);
          console.log("âœ… Track habilitado, chamando videoPreview.show()...");
          videoPreview.show();
          setMedia((prev) => ({ ...prev, isPreviewOn: true }));
          console.log("âœ… videoPreview.show() chamado e isPreviewOn definido como true");
        } else {
          console.error("âŒ Stream Ã© null/undefined");
        }
      } catch (error) {
        console.error("âŒ Erro ao iniciar cÃ¢mera:", error);
      }
    }
    console.log("ðŸŽ¥ toggleCameraPreview: FIM");
  }, [media.isPreviewOn, mediaManager, videoPreview]);

  const toggleVideo = useCallback(async () => {
    // ðŸ”’ SAFETY: If session is active, LiveKit manages hardware.
    // We only update the logical state prevents race conditions.
    if (session.status === "active") {
      console.log("ðŸŽ¥ toggleVideo: Fluxo simplificado (SessÃ£o Ativa) - Apenas State Update");
      setMedia((prev) => ({ ...prev, isVideoEnabled: !prev.isVideoEnabled }));
      return;
    }

    if (media.isVideoEnabled) {
      if (!media.isPreviewOn) {
        await mediaManager.enableVideo(false);
        videoPreview.hide();
      }
      setMedia((prev) => ({ ...prev, isVideoEnabled: false }));
    } else {
      if (!media.isPreviewOn) {
        await mediaManager.startStream();
        await mediaManager.enableVideo(true);
        videoPreview.show();
      } else {
        await mediaManager.setVideoTrackEnabled(true);
      }
      setMedia((prev) => ({ ...prev, isVideoEnabled: true }));
    }
  }, [media.isVideoEnabled, media.isPreviewOn, mediaManager, videoPreview, session.status]);

  const toggleScreenShare = useCallback(async () => {
    if (!media.isScreenSharing) {
      setMedia((prev) => ({ ...prev, isScreenSharing: true }));
      setShowScreenSharePanel(true);
    } else {
      setMedia((prev) => ({ ...prev, isScreenSharing: false }));
      setShowScreenSharePanel(false);
    }
  }, [media.isScreenSharing]);

  const handleSessionConnect = useCallback(() => {
    console.log("ðŸ”„ handleSessionConnect chamado, status atual:", session.status);
    if (session.status === "active") return;
    if (session.status === "paused") {
      sessionMachine.resume();
      return;
    }
    if (session.status === "idle") {
      sessionMachine.start();
    }
  }, [session.status, sessionMachine]);

  const handleSessionPause = useCallback(() => {
    sessionMachine.pause();
  }, [sessionMachine]);

  const handleSessionResume = useCallback(() => {
    sessionMachine.resume();
  }, [sessionMachine]);

  const handleSessionReset = useCallback(() => {
    sessionMachine.reset();
  }, [sessionMachine]);

  const endSession = useCallback(() => {
    sessionMachine.end();
  }, [sessionMachine]);

  const handleOpenSettings = useCallback(() => {
    if (typeof window !== "undefined") {
      window.dispatchEvent(new CustomEvent("openSessionSettings"));
    }
  }, []);

  const toggleHighMesh = useCallback(() => {
    setIsHighMeshEnabled((prev) => !prev);
  }, []);

  const formatTime = useCallback((seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
  }, []);

  const setConsultationIdFromLink = useCallback((token) => {
    setConsultationId(token);
  }, []);

  // ============================================================
  // ðŸ“¤ CONTEXT VALUE
  // ============================================================
  const value = {
    isProfessional,
    onSessionEnd,
    sessionDuration,
    elapsedTime: initialElapsedTime,
    warningThreshold,
    themeColors,
    isVideoOn: media.isVideoEnabled,
    isAudioOn: media.isAudioEnabled,
    isScreenSharing: media.isScreenSharing,
    isFullscreen,
    isConnected: connection.isConnected,
    isSessionActive: session.status !== "idle",
    isSessionStarted: session.status === "active",
    localSessionTime: elapsedTimeState,
    showTimeWarning,
    showScreenSharePanel,
    isCameraPreviewOn: media.isPreviewOn,
    useWhereby,
    isHighMeshEnabled,
    lowPowerMode: connection.lowPowerMode,
    recordingState,
    localVideoRef,
    remoteVideoRef,
    screenShareRef,
    setIsFullscreen,
    setUseWhereby,
    setShowScreenSharePanel,
    setRecordingState,
    toggleVideo,
    toggleAudio,
    toggleCameraPreview,
    toggleScreenShare,
    toggleHighMesh,
    setLowPowerMode: (value) => setConnection((prev) => ({ ...prev, lowPowerMode: value })),
    handleSessionConnect,
    handleSessionPause,
    handleSessionResume,
    handleSessionReset,
    endSession,
    handleOpenSettings,
    formatTime,
    consultationId,
    setConsultationId,
    setConsultationIdFromLink,
    permissionError
  };

  return (
    <VideoPanelContext.Provider value={value}>{children}</VideoPanelContext.Provider>
  );
};

export const useVideoPanel = () => {
  const context = useContext(VideoPanelContext);
  if (!context) {
    throw new Error("useVideoPanel must be used within a VideoPanelProvider");
  }
  return context;
};
