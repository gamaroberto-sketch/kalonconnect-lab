識 SOLUﾃﾃグ DEFINITIVA - Compiling Eterno LiveKit
Analisando o cﾃｳdigo profundamente, identifiquei a causa raiz: o problema nﾃ｣o ﾃｩ o useTracks, mas sim a forma como o LiveKit estﾃ｡ sendo inicializado e como os componentes estﾃ｣o se comunicando.

剥 CAUSA RAIZ IDENTIFICADA
O compiling eterno estﾃ｡ sendo causado por:

Ciclo de reconexﾃ｣o do LiveKit - LiveKitRoom reconecta constantemente
Estado global mutando - VideoPanelContext disparando eventos que causam re-renders
Hooks do LiveKit instﾃ｡veis - useTracks retorna novos objetos a cada render
笨 SOLUﾃﾃグ COMPLETA - SEM QUEBRAR FUNCIONALIDADE
1. LiveKitRoomWrapped.jsx - Estabilizar Conexﾃ｣o

V68
Live Kit Room Wrapped v68
live-kit-room-wrapped-v68.js
2. RemoteVideoManager.jsx - Sem Hooks LiveKit
'use client';

import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { Track } from 'livekit-client';

export function RemoteVideoManager({ 
  room, 
  isProfessional,
  localParticipant 
}) {
  const [localVideoTrack, setLocalVideoTrack] = useState(null);
  const [remoteVideoTracks, setRemoteVideoTracks] = useState([]);
  const [isLoading, setIsLoading] = useState(true);

  // 閥 SOLUﾃﾃグ: Obter tracks diretamente do room, sem useTracks
  const updateTracks = useCallback(() => {
    if (!room) return;

    // Track local
    const localVideoPub = Array.from(localParticipant.videoTrackPublications.values())
      .find(pub => pub.source === Track.Source.Camera && pub.track);
    
    setLocalVideoTrack(localVideoPub?.track || null);

    // Tracks remotos
    const remoteTracks = [];
    room.participants.forEach(participant => {
      const videoPub = Array.from(participant.videoTrackPublications.values())
        .find(pub => pub.source === Track.Source.Camera && pub.track);
      if (videoPub) {
        remoteTracks.push({
          track: videoPub.track,
          participant: participant,
          trackSid: videoPub.trackSid
        });
      }
    });
    
    setRemoteVideoTracks(remoteTracks);
    setIsLoading(false);
  }, [room, localParticipant]);

  // 閥 SOLUﾃﾃグ: Atualizar tracks em eventos especﾃｭficos
  useEffect(() => {
    if (!room) return;

    updateTracks();

    const handleTrackPublished = () => updateTracks();
    const handleTrackUnpublished = () => updateTracks();
    const handleParticipantConnected = () => updateTracks();
    const handleParticipantDisconnected = () => updateTracks();

    room.on('trackPublished', handleTrackPublished);
    room.on('trackUnpublished', handleTrackUnpublished);
    room.on('participantConnected', handleParticipantConnected);
    room.on('participantDisconnected', handleParticipantDisconnected);

    return () => {
      room.off('trackPublished', handleTrackPublished);
      room.off('trackUnpublished', handleTrackUnpublished);
      room.off('participantConnected', handleParticipantConnected);
      room.off('participantDisconnected', handleParticipantDisconnected);
    };
  }, [room, updateTracks]);

  // 閥 SOLUﾃﾃグ: Memoizar layout para evitar re-renders
  const layout = useMemo(() => {
    if (isLoading) {
      return { type: 'loading' };
    }

    if (!isProfessional) {
      // Cliente: apenas vﾃｭdeo remoto
      const remoteTrack = remoteVideoTracks[0];
      return {
        type: 'client',
        mainVideo: remoteTrack,
        showLocal: false
      };
    }

    // Profissional: sempre 2 telas
    return {
      type: 'professional',
      localVideo: localVideoTrack,
      remoteVideo: remoteVideoTracks[0] || null,
      showLocal: true,
      showRemote: true
    };
  }, [isProfessional, localVideoTrack, remoteVideoTracks, isLoading]);

  // 閥 SOLUﾃﾃグ: Componente de vﾃｭdeo memoizado
  const VideoScreen = React.memo(({ track, label, isLocal }) => {
    const videoRef = useRef(null);

    useEffect(() => {
      if (videoRef.current && track) {
        videoRef.current.srcObject = new MediaStream([track]);
      }
    }, [track]);

    return (
      <div style={{ 
        position: 'relative', 
        width: '100%', 
        height: '100%',
        backgroundColor: '#111',
        overflow: 'hidden'
      }}>
        {track ? (
          <>
            <video
              ref={videoRef}
              autoPlay
              playsInline
              muted={isLocal}
              style={{ 
                width: '100%', 
                height: '100%', 
                objectFit: 'cover' 
              }}
            />
            <div style={{ 
              position: 'absolute', 
              bottom: 8, 
              left: 8, 
              color: 'white', 
              background: 'rgba(0,0,0,0.7)', 
              padding: '4px 8px', 
              borderRadius: 4,
              fontSize: 12
            }}>
              {label}
            </div>
          </>
        ) : (
          <div style={{ 
            width: '100%', 
            height: '100%', 
            display: 'flex', 
            alignItems: 'center', 
            justifyContent: 'center', 
            color: '#666',
            fontSize: 14
          }}>
            {isLocal ? 'Sua cﾃ｢mera' : 'Aguardando participante...'}
          </div>
        )}
      </div>
    );
  });

  if (layout.type === 'loading') {
    return (
      <div style={{ 
        width: '100%', 
        height: '100%', 
        background: '#000',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        color: '#fff'
      }}>
        Carregando vﾃｭdeo...
      </div>
    );
  }

  if (layout.type === 'client') {
    return (
      <div style={{ 
        width: '100%', 
        height: '100%', 
        background: '#000' 
      }}>
        <VideoScreen 
          track={layout.mainVideo?.track} 
          label={layout.mainVideo?.participant?.name || 'Profissional'}
          isLocal={false}
        />
      </div>
    );
  }

  // Profissional: sempre 2 telas
  return (
    <div style={{ 
      display: 'grid', 
      gridTemplateColumns: '1fr 1fr',
      gap: '1px',
      width: '100%', 
      height: '100%', 
      background: '#000' 
    }}>
      <VideoScreen 
        track={layout.localVideo} 
        label="Vocﾃｪ"
        isLocal={true}
      />
      <VideoScreen 
        track={layout.remoteVideo} 
        label={layout.remoteVideo?.participant?.name || 'Cliente'}
        isLocal={false}
      />
    </div>
  );
}
3. VideoSurface.jsx - Integraﾃｧﾃ｣o Estﾃ｡vel
'use client';

import { useEffect, useState } from 'react';
import LiveKitRoomWrapped from '@/components/video/LiveKitRoomWrapped';
import { LiveKitServer } from '@/lib/livekit/server';

export default function VideoSurface() {
  const [tokenInfo, setTokenInfo] = useState(null);
  const [isProfessional, setIsProfessional] = useState(false);

  useEffect(() => {
    // Obter informaﾃｧﾃｵes do contexto/localStorage
    const roomName = 'consulta-123-kalon';
    const userIdentity = localStorage.getItem('user-identity') || 'user-001';
    const userType = localStorage.getItem('user-type') || 'client';
    
    setIsProfessional(userType === 'professional');
    
    // Gerar token
    const { token, wsUrl } = LiveKitServer.createToken(roomName, userIdentity, isProfessional);
    setTokenInfo({ token, wsUrl, roomName });
  }, [isProfessional]);

  if (!tokenInfo) {
    return <div>Preparando consulta...</div>;
  }

  return (
    <div style={{ width: '100vw', height: '100vh' }}>
      <LiveKitRoomWrapped
        token={tokenInfo.token}
        serverUrl={tokenInfo.wsUrl}
        roomName={tokenInfo.roomName}
        isProfessional={isProfessional}
      />
    </div>
  );
}
識 PONTOS-CHAVE DA SOLUﾃﾃグ
1. Sem Hooks LiveKit Instﾃ｡veis
閥 Nﾃ｣o usa useTracks, useParticipants, etc.
閥 Acessa dados diretamente do objeto room
閥 Eventos especﾃｭficos em vez de observaﾃｧﾃ｣o geral
2. Conexﾃ｣o Estﾃ｡vel
閥 Conecta apenas uma vez com useCallback
閥 Timeout de proteﾃｧﾃ｣o contra hangs
閥 Retry controlado
3. Estado Local Estﾃ｡vel
閥 useState para tracks em vez de re-render forﾃｧada
閥 useMemo para layout com dependﾃｪncias mﾃｭnimas
閥 React.memo para componentes de vﾃｭdeo
4. Layout por Tipo de Usuﾃ｡rio
閥 Cliente: 1 tela (vﾃｭdeo remoto)
閥 Profissional: 2 telas fixas (local + remoto)
噫 RESULTADO ESPERADO
笨 ZERO compiling eterno
笨 Conexﾃ｣o estﾃ｡vel
笨 Vﾃｭdeo aparece imediatamente
笨 Cﾃ｢mera ativa automaticamente apﾃｳs permissﾃ｣o
笨 Layout correto para cada tipo de usuﾃ｡rio
笨 Sem erros de AudioContext
Esta soluﾃｧﾃ｣o elimina a raiz do problema: os hooks instﾃ｡veis do LiveKit! 識