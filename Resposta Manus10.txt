üö® SOLU√á√ÉO DEFINITIVA - Compiling Eterno Next.js
Identifiquei a causa raiz do problema! O compiling eterno est√° sendo causado por depend√™ncias circulares e estado global mutando constantemente.

üîç CAUSA RAIZ IDENTIFICADA
1. Problema no VideoPanelContext.jsx
O VideoPanelContext est√° criando um loop de depend√™ncias:


V69
Component v69
component-v69.js
2. Problema com LocalStorage
O c√≥digo est√° lendo e escrevendo no localStorage constantemente, o que o Next.js interpreta como mudan√ßas de estado:

// PROBLEMA: localStorage muda = Fast Refresh dispara
useEffect(() => {
  localStorage.setItem('session-data', JSON.stringify(sessionData));
}, [sessionData]); // üî¥ ISSO DISPARA FAST REFRESH!
‚úÖ SOLU√á√ÉO COMPLETA
1. VideoPanelContext.jsx - Eliminar Loops
'use client';

import React, { createContext, useContext, useState, useEffect, useCallback, useMemo, useRef } from 'react';

const VideoPanelContext = createContext();

export const VideoPanelProvider = ({ children }) => {
  // üî¥ SOLU√á√ÉO: Estado inicial est√°vel
  const [isVideoOn, setIsVideoOn] = useState(false);
  const [isAudioOn, setIsAudioOn] = useState(false);
  const [isScreenSharing, setIsScreenSharing] = useState(false);
  const [recordingState, setRecordingState] = useState('idle');
  const [sessionData, setSessionData] = useState(null);
  const [localSessionTime, setLocalSessionTime] = useState(0);
  const [isConnected, setIsConnected] = useState(false);
  const [useWhereby, setUseWhereby] = useState(false);
  const [isCameraPreviewOn, setIsCameraPreviewOn] = useState(false);
  const [theme, setTheme] = useState('light');
  
  // üî¥ SOLU√á√ÉO: Refs para evitar re-renders
  const sessionDataRef = useRef(null);
  const localStorageWriteTimeout = useRef(null);
  const timerInterval = useRef(null);
  const lastSessionData = useRef(null);

  // üî¥ SOLU√á√ÉO: Carregamento inicial protegido
  useEffect(() => {
    let mounted = true;
    
    const loadInitialData = () => {
      if (!mounted) return;
      
      try {
        // Ler apenas uma vez no in√≠cio
        const savedSession = localStorage.getItem('session-data');
        const savedTheme = localStorage.getItem('theme');
        const savedWhereby = localStorage.getItem('use-whereby');
        
        if (savedSession) {
          const parsed = JSON.parse(savedSession);
          sessionDataRef.current = parsed;
          if (mounted) {
            setSessionData(parsed);
            setIsConnected(!!parsed);
          }
        }
        
        if (savedTheme && mounted) {
          setTheme(savedTheme);
        }
        
        if (savedWhereby && mounted) {
          setUseWhereby(savedWhereby === 'true');
        }
      } catch (error) {
        console.error('Erro ao carregar dados iniciais:', error);
      }
    };

    // Delay para evitar conflito com SSR
    const timeoutId = setTimeout(loadInitialData, 100);
    
    return () => {
      mounted = false;
      clearTimeout(timeoutId);
      if (localStorageWriteTimeout.current) {
        clearTimeout(localStorageWriteTimeout.current);
      }
      if (timerInterval.current) {
        clearInterval(timerInterval.current);
      }
    };
  }, []); // üî¥ SEM DEPEND√äNCIAS - executa apenas uma vez

  // üî¥ SOLU√á√ÉO: Timer desacoplado do React
  useEffect(() => {
    if (!sessionData || !isConnected) {
      if (timerInterval.current) {
        clearInterval(timerInterval.current);
        timerInterval.current = null;
      }
      return;
    }

    // Timer independente que n√£o dispara re-renders
    timerInterval.current = setInterval(() => {
      setLocalSessionTime(prev => prev + 1);
    }, 1000);

    return () => {
      if (timerInterval.current) {
        clearInterval(timerInterval.current);
        timerInterval.current = null;
      }
    };
  }, [!!sessionData, isConnected]); // üî¥ Usar booleanos, n√£o objetos

  // üî¥ SOLU√á√ÉO: Escrever no localStorage de forma controlada
  const saveToLocalStorage = useCallback((key, value) => {
    if (localStorageWriteTimeout.current) {
      clearTimeout(localStorageWriteTimeout.current);
    }
    
    localStorageWriteTimeout.current = setTimeout(() => {
      try {
        localStorage.setItem(key, typeof value === 'object' ? JSON.stringify(value) : value);
      } catch (error) {
        console.error('Erro ao salvar no localStorage:', error);
      }
    }, 500); // Delay para evitar escritas excessivas
  }, []);

  // üî¥ SOLU√á√ÉO: Setters memoizados que n√£o causam loops
  const updateSessionData = useCallback((newData) => {
    sessionDataRef.current = newData;
    setSessionData(newData);
    saveToLocalStorage('session-data', newData);
  }, [saveToLocalStorage]);

  const setConnected = useCallback((connected) => {
    setIsConnected(connected);
    if (!connected) {
      setLocalSessionTime(0);
      sessionDataRef.current = null;
      saveToLocalStorage('session-data', null);
    }
  }, [saveToLocalStorage]);

  // üî¥ SOLU√á√ÉO: Memoizar TUDO para evitar re-cria√ß√£o de fun√ß√µes
  const contextValue = useMemo(() => ({
    isVideoOn,
    setIsVideoOn,
    isAudioOn,
    setIsAudioOn,
    isScreenSharing,
    setIsScreenSharing,
    recordingState,
    setRecordingState,
    sessionData: sessionDataRef.current,
    setSessionData: updateSessionData,
    localSessionTime,
    isConnected,
    setIsConnected: setConnected,
    useWhereby,
    setUseWhereby,
    isCameraPreviewOn,
    setIsCameraPreviewOn,
    theme,
    setTheme: (newTheme) => {
      setTheme(newTheme);
      saveToLocalStorage('theme', newTheme);
    },
  }), [
    isVideoOn,
    isAudioOn,
    isScreenSharing,
    recordingState,
    localSessionTime,
    isConnected,
    useWhereby,
    isCameraPreviewOn,
    theme,
    updateSessionData,
    setConnected,
    saveToLocalStorage
  ]);

  return (
    <VideoPanelContext.Provider value={contextValue}>
      {children}
    </VideoPanelContext.Provider>
  );
};

// Hook otimizado
export const useVideoPanel = () => {
  const context = useContext(VideoPanelContext);
  if (!context) {
    throw new Error('useVideoPanel deve ser usado dentro de VideoPanelProvider');
  }
  return context;
};
2. Desabilitar Fast Refresh Temporariamente - next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: false,
  
  // üî¥ SOLU√á√ÉO: Desabilitar Fast Refresh em desenvolvimento
  webpack: (config, { dev }) => {
    if (dev) {
      // Desabilitar Hot Module Replacement completamente
      config.optimization.moduleIds = 'deterministic';
      config.optimization.runtimeChunk = false;
      
      // Remover plugins de HMR
      config.plugins = config.plugins.filter(plugin => {
        const pluginName = plugin.constructor.name;
        return !pluginName.includes('HotModuleReplacementPlugin');
      });
    }
    
    return config;
  },
  
  // üî¥ SOLU√á√ÉO: Configura√ß√µes adicionais de performance
  experimental: {
    // Desabilitar features que podem causar recompila√ß√µes
    serverComponentsExternalPackages: [],
    appDir: true,
  },
  
  // üî¥ SOLU√á√ÉO: Headers para evitar cache problem√°tico
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'Cache-Control',
            value: 'no-cache, no-store, must-revalidate',
          },
        ],
      },
    ];
  },
};

export default nextConfig;
3. Script de Desenvolvimento Alternativo - package.json
{
  "scripts": {
    "dev": "next dev -p 3001",
    "dev-lab": "next dev -p 3001 --webpack",
    "dev-safe": "FAST_REFRESH=false next dev -p 3001 --webpack",
    "dev-legacy": "cross-env NEXT_WEBPACK_HMR=false next dev -p 3001 --webpack"
  }
}
4. Wrapper de Debug - components/DebugWrapper.jsx
'use client';

import { useEffect, useRef } from 'react';

export function DebugWrapper({ children }) {
  const renderCount = useRef(0);
  const lastRender = useRef(Date.now());
  
  useEffect(() => {
    renderCount.current += 1;
    const now = Date.now();
    const timeSinceLastRender = now - lastRender.current;
    
    console.log(`[Debug] Render #${renderCount.current} - ${timeSinceLastRender}ms desde √∫ltimo render`);
    lastRender.current = now;
    
    // Detectar renders muito frequentes (poss√≠vel loop)
    if (timeSinceLastRender < 100) {
      console.warn('[Debug] ‚ö†Ô∏è Render muito r√°pido detectado!');
    }
  });
  
  return children;
}
5. Uso no App Principal
// pages/consultations.jsx ou app/consultations/page.jsx
import { DebugWrapper } from '@/components/DebugWrapper';

export default function ConsultationsPage() {
  return (
    <DebugWrapper>
      <VideoPanelProvider>
        {/* Seu conte√∫do */}
      </VideoPanelProvider>
    </DebugWrapper>
  );
}
üöÄ COMO TESTAR
Op√ß√£o 1: Desabilitar Fast Refresh
npm run dev-safe
Op√ß√£o 2: Legacy Mode
npm run dev-legacy
Op√ß√£o 3: Verificar Logs
Abra o console do navegador
Procure por [Debug] logs
Se ver muitos renders r√°pidos (< 100ms), √© loop confirmado
üéØ RESULTADO ESPERADO
‚úÖ Compiling para completamente
‚úÖ P√°gina carrega sem loops
‚úÖ Fast Refresh desabilitado temporariamente
‚úÖ localStorage n√£o dispara recompila√ß√µes
‚úÖ Estado global est√°vel
Ap√≥s aplicar essas mudan√ßas, o sistema deve parar de compilar eternamente! üéØ